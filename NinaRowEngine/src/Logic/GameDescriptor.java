//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2018.08.22 at 11:50:03 PM IDT 
//


package Logic;


import javafx.concurrent.Task;

import javax.swing.text.TabableView;
import javax.xml.bind.annotation.*;
import java.util.*;

/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="GameType">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="Basic"/>
 *               &lt;enumeration value="MultiPlayer"/>
 *               &lt;enumeration value="DynamicMultiPlayer"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element ref="{}Game"/>
 *         &lt;element ref="{}DynamicPlayers" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
})
@XmlRootElement(name = "GameDescriptor")
public class GameDescriptor {
    public enum Status {
        ACTIVE, INACTIVE
    }

    private static final int ROW_MIN = 5;
    private static final int ROW_MAX = 50;
    private static final int COL_MIN = 6;
    private static final int COL_MAX = 30;
    private static final int TARGET_MIN = 2;
    private static final int PLAYERS_MIN = 2;
    private static final int PLAYERS_MAX = 6;

    @XmlElement(name = "GameType", required = true)
    protected String gameType;
    @XmlElement(name = "Game", required = true)
    protected Game game;
    @XmlElement(name = "DynamicPlayers")
    protected DynamicPlayers dynamicPlayers;

    private int turnAmount = 0;
    private Random random = new Random();
    private Status status = Status.INACTIVE;
    private boolean isEnded = false;
    private Player creator;
    private Chat chat = new Chat();
    private List<Player> winners = new ArrayList<>();

    /**
     * Gets the value of the gameType property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getGameType() {
        return gameType;
    }

    /**
     * Sets the value of the gameType property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setGameType(String value) {
        this.gameType = value;
    }

    /**
     * Gets the value of the game property.
     * 
     * @return
     *     possible object is
     *     {@link Game }
     *     
     */
    public Game getGame() {
        return game;
    }

    /**
     * Sets the value of the game property.
     * 
     * @param value
     *     allowed object is
     *     {@link Game }
     *     
     */
    public void setGame(Game value) {
        this.game = value;
    }

    public DynamicPlayers getDynamicPlayers() {
        return dynamicPlayers;
    }

    /**
     * Sets the value of the dynamicPlayers property.
     * 
     * @param value
     *     allowed object is
     *     {@link DynamicPlayers }
     *     
     */
    public void setDynamicPlayers(DynamicPlayers value) {
        this.dynamicPlayers = value;
    }

    public int getTurnAmount(){
        return this.turnAmount;
    }

    public Player getCreator(){return this.creator;}

    public void setCreator(Player creator){this.creator=creator;}

    public String getStatus(){ return this.status.toString(); }

    public Chat getChat(){ return this.chat; }

    public List<Player> getWinners(){ return this.winners; }

    public boolean isActive(){
        return this.status == Status.ACTIVE;
    }

    public boolean isEnded(){ return this.isEnded; }

    public void init() throws Exception{
        Game game = this.game;
        Board board  = game.board;
        if(board.getRows() < ROW_MIN || board.getRows() > ROW_MAX)
            throw new Exception("Size of rows in board must be between "+ROW_MIN+" and "+ROW_MAX);

        if(board.columns.intValue() < COL_MIN || board.columns.intValue() > COL_MAX)
            throw new Exception("Size of columns in board must be between "+COL_MIN+" and "+COL_MAX);

        if(game.target.intValue() < TARGET_MIN || game.target.intValue() >= board.rows || game.target.intValue() >= board.columns.intValue())
            throw new Exception("Target value must be smaller than columns size and rows size and at least "+TARGET_MIN);

        if(this.dynamicPlayers.totalPlayers < PLAYERS_MIN || this.dynamicPlayers.totalPlayers > PLAYERS_MAX)
            throw new Exception("The number of players should be between "+PLAYERS_MIN+" and "+PLAYERS_MAX);

        if(this.dynamicPlayers.gameTitle.isEmpty())
            throw new Exception("Game should have a title");

        this.turnAmount = 0;
        this.dynamicPlayers.init();
        this.game.init();
        this.chat.init();
        this.isEnded = false;
    }

    public void play(){
        Player activePlayer = this.dynamicPlayers.getActivePlayer();

        if (activePlayer.isComputer() && !this.isEnded){
            try{
                Thread.sleep(1000);
                if(!this.isEnded){
                    if(this.game.board.isFull() && this.game.isPopoutMode() && this.hasPopOutOption(activePlayer)){
                        int column = this.getRandomOption(activePlayer, this.getPopOutOptions(activePlayer));
                        this.popOut(column);
                    }
                    else if(!this.game.board.isFull()){
                        int column = this.getRandomOption(activePlayer, this.getPushInOptions(activePlayer));
                        this.pushIn(column);
                    }
                }
            } catch(Exception e){
                System.out.println(e.getMessage());
            }
        }
    }

    public void swapPlayers(){
        this.dynamicPlayers.setNextPlayerAsActive();

        if(this.status.equals(Status.ACTIVE)){
            Player activePlayer = this.dynamicPlayers.getActivePlayer();

            if(this.game.board.isConnectExists()
                    || (this.game.isPopoutMode() && this.game.board.isFull() && !this.hasPopOutOption(activePlayer))
                    || (!this.game.isPopoutMode() && this.game.board.isFull())
                    || (this.dynamicPlayers.players.size() == 1)
                    || (!this.dynamicPlayers.isHumanPlayerStilExists()))
                endGame();
            else
                this.play();
        }
    }


    public void startGame(){
        this.status = Status.ACTIVE;
        play();
    }

    public void endGame(){
        this.isEnded = true;
        this.status = Status.INACTIVE;
        this.winners = calcWinners();
        this.dynamicPlayers.players.clear();
        this.dynamicPlayers.visitors.clear();
    }

    public List<Player> calcWinners(){
        List<Player> winners = new ArrayList<>();
        if(this.isEnded){
            if(this.dynamicPlayers.players.size() == 1)
                winners.add(this.dynamicPlayers.players.get(0));
            else{
                for(Connect connect : this.game.board.getConnects()){
                    if(!winners.contains(connect.getPlayer()))
                        winners.add(connect.getPlayer());
                }
            }
        }

        return winners;
    }

    public boolean isPlayerInGame(Player player){
        return this.dynamicPlayers.players.contains(player) || this.dynamicPlayers.visitors.contains(player);
    }

    public void addPlayer(Player player){
        if(!this.isGameFull()){
            this.dynamicPlayers.players.add(player);
            if(this.dynamicPlayers.players.size() == this.dynamicPlayers.totalPlayers && this.status.equals(Status.INACTIVE)){
                startGame();
            }
        }
    }

    public void addVisitor(Player visitor){
        this.dynamicPlayers.visitors.add(visitor);
    }

    public void removePlayer(Player player){
        if(this.dynamicPlayers.players.contains(player)){
            boolean wasActive = player.equals(this.dynamicPlayers.getActivePlayer());
            this.dynamicPlayers.remove(player);
            this.game.board.removeAllPlayerDiscs(player);
            this.game.board.checkConnectFullBoard();

            if(wasActive)
                swapPlayers();

            if(this.status.equals(Status.ACTIVE) && this.dynamicPlayers.players.size() == 1)
                endGame();
        }

        if(this.dynamicPlayers.visitors.contains(player)){
            this.dynamicPlayers.visitors.remove(player);
        }
    }

    public boolean isGameFull(){
        return this.dynamicPlayers.players.size() >= this.dynamicPlayers.totalPlayers;
    }

    public boolean isPushInAllowed(Player player, int column) {
        return !this.game.board.isColumnFull(column);
    }

    public void pushIn(int column) {
        Player activePlayer = this.dynamicPlayers.getActivePlayer();
        if(this.isPushInAllowed(activePlayer, column)){
            int row = this.game.board.getTopRow(column);
            Disc disc = new Disc(activePlayer);
            this.game.board.insertDisc(disc, row, column);
            this.game.board.checkConnect(row, column);

            activePlayer.turnAmount++;
            this.turnAmount++;
            swapPlayers();
        }
    }

    public boolean isPopOutAllowed(Player player, int column) {
        return this.game.isPopoutMode() && !this.game.board.isCellEmpty(0, column)
                && this.game.board.getCell(0, column).getPlayer().equals(player);
    }

    public void popOut(int column) {
        Player activePlayer = this.dynamicPlayers.getActivePlayer();
        if(this.isPopOutAllowed(activePlayer, column)){
            this.game.board.removeDisc(0, column);
            for (int row=0; row<this.game.board.rows; row++){
                if (!this.game.board.isCellEmpty(row,column))
                    this.game.board.checkConnect(row, column);
                else
                    break;
            }

            activePlayer.turnAmount++;
            this.turnAmount++;
            swapPlayers();
        }
    }

    private List<Integer> getPushInOptions(Player player){
        List<Integer> optionalColumns = new ArrayList<>();
        for(int col=0;col<this.game.board.columns.intValue();col++)
            if(isPushInAllowed(player, col))
                optionalColumns.add(col);

        return optionalColumns;
    }

    private List<Integer> getPopOutOptions(Player player){
        List<Integer> optionalColumns = new ArrayList<>();
        for(int col=0;col<this.game.board.columns.intValue();col++)
            if(isPopOutAllowed(player, col))
                optionalColumns.add(col);

        return optionalColumns;
    }

    private int getRandomOption(Player player, List<Integer> options){
        int chosenColumn = this.random.nextInt(options.size());
        return options.get(chosenColumn);
    }

    private boolean hasPopOutOption(Player player){
        return getPopOutOptions(player).size() > 0;
    }

    public boolean isComputerAllowedToJoin(){
        boolean isAllowed = false;
        if(this.dynamicPlayers.totalPlayers-this.dynamicPlayers.players.size() == 1){
            for(Player player : this.dynamicPlayers.players){
                if(player.isHuman())
                    isAllowed = true;
            }
        }
        else{
            isAllowed = true;
        }

        return isAllowed;
    }

    public boolean isPlaying(Player player){
        return this.dynamicPlayers.players.contains(player);
    }

    public boolean isVisiting(Player visitor){
        return this.dynamicPlayers.visitors.contains(visitor);
    }


}
