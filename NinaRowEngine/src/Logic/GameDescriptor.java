//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.8-b130911.1802 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2018.08.22 at 11:50:03 PM IDT 
//


package Logic;


import javafx.concurrent.Task;

import javax.swing.text.TabableView;
import javax.xml.bind.annotation.*;
import java.util.*;

/**
 * <p>Java class for anonymous complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element name="GameType">
 *           &lt;simpleType>
 *             &lt;restriction base="{http://www.w3.org/2001/XMLSchema}string">
 *               &lt;enumeration value="Basic"/>
 *               &lt;enumeration value="MultiPlayer"/>
 *               &lt;enumeration value="DynamicMultiPlayer"/>
 *             &lt;/restriction>
 *           &lt;/simpleType>
 *         &lt;/element>
 *         &lt;element ref="{}Game"/>
 *         &lt;element ref="{}DynamicPlayers" minOccurs="0"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 * 
 * 
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
})
@XmlRootElement(name = "GameDescriptor")
public class GameDescriptor {
    public enum Status {
        ACTIVE, INACTIVE
    }

    private static final int ROW_MIN = 5;
    private static final int ROW_MAX = 50;
    private static final int COL_MIN = 6;
    private static final int COL_MAX = 30;
    private static final int TARGET_MIN = 2;
    private static final int PLAYERS_MIN = 2;
    private static final int PLAYERS_MAX = 6;

    @XmlElement(name = "GameType", required = true)
    protected String gameType;
    @XmlElement(name = "Game", required = true)
    protected Game game;
    @XmlElement(name = "DynamicPlayers")
    protected DynamicPlayers dynamicPlayers;

    private History history = new History();
    private int turnAmount = 0;
    private Random random = new Random();
    private Status status = Status.INACTIVE;
    private boolean isEnded = false;
    private Player creator;

    /**
     * Gets the value of the gameType property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getGameType() {
        return gameType;
    }

    /**
     * Sets the value of the gameType property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setGameType(String value) {
        this.gameType = value;
    }

    /**
     * Gets the value of the game property.
     * 
     * @return
     *     possible object is
     *     {@link Game }
     *     
     */
    public Game getGame() {
        return game;
    }

    /**
     * Sets the value of the game property.
     * 
     * @param value
     *     allowed object is
     *     {@link Game }
     *     
     */
    public void setGame(Game value) {
        this.game = value;
    }

    public DynamicPlayers getDynamicPlayers() {
        return dynamicPlayers;
    }

    /**
     * Sets the value of the dynamicPlayers property.
     * 
     * @param value
     *     allowed object is
     *     {@link DynamicPlayers }
     *     
     */
    public void setDynamicPlayers(DynamicPlayers value) {
        this.dynamicPlayers = value;
    }

    public int getTurnAmount(){
        return this.turnAmount;
    }

    public List<Move> getHistoryMoves(){
        return this.history.getMoves();
    }

    public Player getCreator(){return this.creator;}

    public void setCreator(Player creator){this.creator=creator;}

    public String getStatus(){ return this.status.toString(); }

    public boolean isActive(){
        return this.status == Status.ACTIVE;
    }

    public boolean isEnded(){ return this.isEnded; }

    public void init() throws Exception{
        Game game = this.game;
        Board board  = game.board;
        if(board.getRows() < ROW_MIN || board.getRows() > ROW_MAX)
            throw new Exception("Size of rows in board must be between "+ROW_MIN+" and "+ROW_MAX);

        if(board.columns.intValue() < COL_MIN || board.columns.intValue() > COL_MAX)
            throw new Exception("Size of columns in board must be between "+COL_MIN+" and "+COL_MAX);

        if(game.target.intValue() < TARGET_MIN || game.target.intValue() >= board.rows || game.target.intValue() >= board.columns.intValue())
            throw new Exception("Target value must be smaller than columns size and rows size and at least "+TARGET_MIN);

        if(this.dynamicPlayers.totalPlayers < PLAYERS_MIN || this.dynamicPlayers.totalPlayers > PLAYERS_MAX)
            throw new Exception("The number of players should be between "+PLAYERS_MIN+" and "+PLAYERS_MAX);

        if(this.dynamicPlayers.gameTitle.isEmpty())
            throw new Exception("Game should have a title");

        this.turnAmount = 0;
        this.dynamicPlayers.init();
        this.history.init();
        this.game.init();
        this.isEnded = false;
    }

    public void executePlayerMove(int col, BoardOperation operation){
        Player activePlayer = this.dynamicPlayers.getActivePlayer();
        if(operation.isAllowed(activePlayer, col)){
            operation.execute(activePlayer, col);
            activePlayer.turnAmount++;
            this.turnAmount++;
            this.history.addMove(new Move(this.turnAmount, activePlayer, operation.toString(), col));
            swapPlayers();
        }
    }

    public void play(){
        Player activePlayer = this.dynamicPlayers.getActivePlayer();

        if (activePlayer.isComputer() && !this.isEnded){
            SleeperTask sleeper = new SleeperTask();
            sleeper.setOnSucceeded(event ->
            {
                if(!this.isEnded){
                    if(this.game.board.isFull() && this.game.isPopoutMode() && this.game.popOut.hasOption(activePlayer)){
                        int column = this.game.popOut.getRandomOption(activePlayer);
                        executePlayerMove(column, this.game.popOut);
                    }
                    else if(!this.game.board.isFull()){
                        int column = this.game.pushIn.getRandomOption(activePlayer);
                        executePlayerMove(column, this.game.pushIn);
                    }
                }
            });

            Thread computerPlay = new Thread(sleeper);
            computerPlay.start();
        }
    }

    public void swapPlayers(){
        this.dynamicPlayers.setNextPlayerAsActive();

        if(this.status.equals(Status.ACTIVE)){
            Player activePlayer = this.dynamicPlayers.getActivePlayer();

            if(this.game.board.isConnectExists()
                    || (this.game.isPopoutMode() && this.game.board.isFull() && !this.game.popOut.hasOption(activePlayer))
                    || (!this.game.isPopoutMode() && this.game.board.isFull())
                    || (this.dynamicPlayers.players.size() == 1))
                endGame();
            else
                this.play();
        }
    }


    public void startGame(){
//        this.turnAmount = 0;
//        this.dynamicPlayers.init();
//        this.history.init();
//        this.game.init();
//        this.isEnded = false;
        this.status = Status.ACTIVE;

        play();
    }

    public void endGame(){
        this.isEnded = true;
        this.status = Status.INACTIVE;
    }

    public List<Player> getWinners(){
        List<Player> winners = new ArrayList<>();
        if(this.isEnded){
            if(this.dynamicPlayers.players.size() == 1)
                winners.add(this.dynamicPlayers.players.get(0));
            else{
                for(Connect connect : this.game.board.getConnects()){
                    if(!winners.contains(connect.getPlayer()))
                        winners.add(connect.getPlayer());
                }
            }
        }

        return winners;
    }

    public boolean isPlayerInGame(Player player){
        return this.dynamicPlayers.players.contains(player) || this.dynamicPlayers.visitors.contains(player);
    }

    public void addPlayer(Player player){
        if(!this.isGameFull()){
            this.dynamicPlayers.players.add(player);
            if(this.dynamicPlayers.players.size() == this.dynamicPlayers.totalPlayers && this.status.equals(Status.INACTIVE)){
                startGame();
            }
        }
    }

    public void addVisitor(Player visitor){
        this.dynamicPlayers.visitors.add(visitor);
    }

    public void removePlayer(Player player){
        boolean wasActive = player.equals(this.dynamicPlayers.getActivePlayer());
        if(this.dynamicPlayers.players.contains(player)){
            this.dynamicPlayers.remove(player);
            this.game.board.removeAllPlayerDiscs(player);
            this.game.board.checkConnectFullBoard();
            if(wasActive)
                swapPlayers();
        }

        if(this.dynamicPlayers.visitors.contains(player)){
            this.dynamicPlayers.visitors.remove(player);
        }
    }

    public boolean isGameFull(){
        return this.dynamicPlayers.players.size() >= this.dynamicPlayers.totalPlayers;
    }


}
